import { Router } from 'express';
import { z } from 'zod';
import { authenticate } from '../middleware/auth';
import { canSendMessages } from '../middleware/ownerAccess';
import { prisma } from '../utils/prisma';
import { AppError } from '../middleware/errorHandler';
import { getBot } from '../services/telegram/botManager';
import axios from 'axios';
import { logger } from '../utils/logger';
import { messageLimiter } from '../middleware/rateLimiter';

const router = Router();

const sendMessageSchema = z.object({
  text: z.string().min(1)
});

// Get dialogs for bots
router.get('/', authenticate, async (req, res, next) => {
  try {
    const { status, page = '1', limit = '20', filter = 'all', botId } = req.query;

    let botIds: string[] = [];
    
    if (req.user!.role === 'OWNER') {
      // Owner sees dialogs from all their bots
      const bots = await prisma.bot.findMany({
        where: { ownerId: req.user!.id },
        select: { id: true }
      });
      botIds = bots.map(b => b.id);
    } else if (req.user!.role === 'MANAGER') {
      // Manager sees dialogs from assigned bots
      const botManagers = await prisma.botManager.findMany({
        where: { userId: req.user!.id },
        select: { botId: true }
      });
      botIds = botManagers.map(bm => bm.botId);
    } else if (req.user!.role === 'ADMIN') {
      // Admin sees all dialogs
      if (botId) {
        botIds = [botId as string];
      } else {
        const bots = await prisma.bot.findMany({ select: { id: true } });
        botIds = bots.map(b => b.id);
      }
    }

    if (botIds.length === 0) {
      throw new AppError(403, 'No bot access');
    }

    // If specific botId is provided, filter to that bot
    const where: any = botId ? { botId } : { botId: { in: botIds } };
    if (status) {
      where.status = status;
    }
    
    // –§–∏–ª—å—Ç—Ä –ø–æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—é
    if (filter === 'my') {
      where.assignedToId = req.user!.id;
      // –î–ª—è "–ú–æ–∏" - –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–∫—Ä—ã—Ç—ã–µ
      if (!status) {
        where.status = { not: 'CLOSED' };
      }
    } else if (filter === 'unassigned') {
      where.assignedToId = null;
      // –î–ª—è "–°–≤–æ–±–æ–¥–Ω—ã–µ" - –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–∫—Ä—ã—Ç—ã–µ
      if (!status) {
        where.status = { not: 'CLOSED' };
      }
    } else if (filter === 'all') {
      // –î–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–µ–≤ - –≤–∏–¥—è—Ç –≤—Å–µ –¥–∏–∞–ª–æ–≥–∏ –≤–∫–ª—é—á–∞—è –∑–∞–∫—Ä—ã—Ç—ã–µ
      if (req.user?.role === 'OWNER' || req.user?.role === 'ADMIN') {
        // –í–ª–∞–¥–µ–ª—å—Ü—ã –∏ –∞–¥–º–∏–Ω—ã –≤–∏–¥—è—Ç –≤—Å–µ –¥–∏–∞–ª–æ–≥–∏
      } else {
        // –ú–µ–Ω–µ–¥–∂–µ—Ä—ã –≤–∏–¥—è—Ç —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ –∏ —Å–≤–æ–±–æ–¥–Ω—ã–µ –¥–∏–∞–ª–æ–≥–∏ (–±–µ–∑ –∑–∞–∫—Ä—ã—Ç—ã—Ö)
        where.OR = [
          { assignedToId: req.user!.id },
          { assignedToId: null }
        ];
        if (!status) {
          where.status = { not: 'CLOSED' };
        }
      }
    }

    const dialogs = await prisma.dialog.findMany({
      where,
      select: {
        id: true,
        telegramChatId: true,
        customerName: true,
        customerUsername: true,
        customerPhotoUrl: true,
        status: true,
        closeReason: true,
        createdAt: true,
        lastMessageAt: true,
        assignedToId: true,
        assignedAt: true,
        closedAt: true,
        botId: true,
        messages: {
          take: 1,
          orderBy: { createdAt: 'desc' }
        },
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            username: true
          }
        }
      },
      orderBy: { lastMessageAt: 'desc' },
      take: parseInt(limit as string),
      skip: (parseInt(page as string) - 1) * parseInt(limit as string)
    });

    const total = await prisma.dialog.count({ where });

    res.json({
      dialogs,
      pagination: {
        page: parseInt(page as string),
        limit: parseInt(limit as string),
        total,
        pages: Math.ceil(total / parseInt(limit as string))
      }
    });
  } catch (error) {
    next(error);
  }
});

// Get dialog messages
router.get('/:id/messages', authenticate, async (req, res, next) => {
  try {
    const { id } = req.params;
    const { page = '1', limit = '50' } = req.query;

    const dialog = await prisma.dialog.findUnique({
      where: { id },
      include: { bot: true }
    });

    if (!dialog) {
      throw new AppError(404, 'Dialog not found');
    }

    // Check if user has access to this bot
    const hasAccess = req.user!.role === 'ADMIN' || 
      dialog.bot.ownerId === req.user!.id ||
      await prisma.botManager.findFirst({
        where: {
          botId: dialog.botId,
          userId: req.user!.id
        }
      });

    if (!hasAccess) {
      throw new AppError(403, 'Access denied');
    }

    const messages = await prisma.message.findMany({
      where: { dialogId: id },
      orderBy: { createdAt: 'desc' },
      take: parseInt(limit as string),
      skip: (parseInt(page as string) - 1) * parseInt(limit as string)
    });

    // Include dialog details for avatar updates
    const dialogDetails = await prisma.dialog.findUnique({
      where: { id },
      select: {
        id: true,
        customerName: true,
        customerUsername: true,
        customerPhotoUrl: true,
        status: true
      }
    });

    res.json({ 
      messages: messages.reverse(),
      dialog: dialogDetails 
    });
  } catch (error) {
    next(error);
  }
});

// Send message to dialog
router.post('/:id/messages', authenticate, canSendMessages, messageLimiter, async (req, res, next) => {
  try {
    const { id } = req.params;
    const { text } = sendMessageSchema.parse(req.body);

    const dialog = await prisma.dialog.findUnique({
      where: { id },
      include: { bot: true }
    });

    if (!dialog) {
      throw new AppError(404, 'Dialog not found');
    }

    // Check if user has access to this bot
    const hasAccess = req.user!.role === 'ADMIN' || 
      dialog.bot.ownerId === req.user!.id ||
      await prisma.botManager.findFirst({
        where: {
          botId: dialog.botId,
          userId: req.user!.id
        }
      });

    if (!hasAccess) {
      throw new AppError(403, 'Access denied');
    }

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–ª–∞–¥–µ–ª—å—Ü–µ–º
    const isOwner = req.user?.role === 'OWNER';

    // Send message via Telegram bot
    const bot = getBot(dialog.botId);
    if (!bot) {
      throw new AppError(500, 'Bot not available');
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –≤–ª–∞–¥–µ–ª—å—Ü–∞ –≤ —á—É–∂–∏—Ö –¥–∏–∞–ª–æ–≥–∞—Ö
    let messageText = text;
    if (isOwner && dialog.assignedToId && dialog.assignedToId !== req.user!.id) {
      messageText = `üë§ [–í–ª–∞–¥–µ–ª–µ—Ü –º–∞–≥–∞–∑–∏–Ω–∞]: ${text}`;
    }

    const sentMessage = await bot.sendMessage(Number(dialog.telegramChatId), messageText);

    // Save message
    const message = await prisma.message.create({
      data: {
        dialogId: id,
        text,
        fromUser: false,
        messageType: 'TEXT',
        telegramId: BigInt(sentMessage.message_id)
      }
    });

    // Update dialog and assign to current user if not assigned
    const updateData: any = { 
      lastMessageAt: new Date(),
      status: 'ACTIVE'
    };
    
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –æ—Ç–≤–µ—Ç–µ
    // –ù–û: –í–ª–∞–¥–µ–ª–µ—Ü –Ω–µ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ –¥–∏–∞–ª–æ–≥–∏
    
    if (!dialog.assignedToId) {
      // –î–∏–∞–ª–æ–≥ —Å–≤–æ–±–æ–¥–µ–Ω - –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º
      updateData.assignedToId = req.user!.id;
      updateData.assignedAt = new Date();
      
      // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–µ–π—Å—Ç–≤–∏–µ "–í–∑—è–ª —Å–µ–±–µ"
      await prisma.dialogAction.create({
        data: {
          dialogId: dialog.id,
          userId: req.user!.id,
          action: 'ASSIGNED'
        }
      });
    } else if (dialog.assignedToId !== req.user!.id && !isOwner) {
      // –î–∏–∞–ª–æ–≥ –∑–∞—Ö–≤–∞—á–µ–Ω –¥—Ä—É–≥–∏–º, –∏ —ç—Ç–æ –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü - –±–ª–æ–∫–∏—Ä—É–µ–º
      throw new AppError(403, 'Dialog is assigned to another manager');
    }
    // –ï—Å–ª–∏ –≤–ª–∞–¥–µ–ª–µ—Ü –æ—Ç–≤–µ—á–∞–µ—Ç –≤ —á—É–∂–æ–π –¥–∏–∞–ª–æ–≥ - –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ –∑–∞—Ö–≤–∞—Ç–∞
    
    await prisma.dialog.update({
      where: { id },
      data: updateData
    });

    res.json(message);
  } catch (error) {
    next(error);
  }
});

// Update dialog status
router.patch('/:id/status', authenticate, async (req, res, next) => {
  try {
    const { id } = req.params;
    const { status, closeReason } = req.body;

    const dialog = await prisma.dialog.findUnique({
      where: { id },
      include: { bot: true }
    });

    if (!dialog) {
      throw new AppError(404, 'Dialog not found');
    }

    // Check if user has access to this bot
    const hasAccess = req.user!.role === 'ADMIN' || 
      dialog.bot.ownerId === req.user!.id ||
      await prisma.botManager.findFirst({
        where: {
          botId: dialog.botId,
          userId: req.user!.id
        }
      });

    if (!hasAccess) {
      throw new AppError(403, 'Access denied');
    }

    const updateData: any = { status };
    
    // –ï—Å–ª–∏ –∑–∞–∫—Ä—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ - —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–∏—á–∏–Ω—É –∏ –≤—Ä–µ–º—è
    if (status === 'CLOSED' && closeReason) {
      updateData.closeReason = closeReason;
      updateData.closedAt = new Date();
    } else if (status !== 'CLOSED') {
      // –ï—Å–ª–∏ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ - –æ—á–∏—â–∞–µ–º –ø—Ä–∏—á–∏–Ω—É –∑–∞–∫—Ä—ã—Ç–∏—è
      updateData.closeReason = null;
      updateData.closedAt = null;
    }

    const updatedDialog = await prisma.dialog.update({
      where: { id },
      data: updateData
    });

    res.json(updatedDialog);
  } catch (error) {
    next(error);
  }
});

// Claim dialog (–∑–∞—Ö–≤–∞—Ç–∏—Ç—å –¥–∏–∞–ª–æ–≥)
router.post('/:id/claim', authenticate, async (req, res, next) => {
  try {
    const { id } = req.params;

    const dialog = await prisma.dialog.findUnique({
      where: { id },
      include: { bot: true }
    });

    if (!dialog) {
      throw new AppError(404, 'Dialog not found');
    }

    // Check if user has access to this bot
    const hasAccess = req.user!.role === 'ADMIN' || 
      dialog.bot.ownerId === req.user!.id ||
      await prisma.botManager.findFirst({
        where: {
          botId: dialog.botId,
          userId: req.user!.id
        }
      });

    if (!hasAccess) {
      throw new AppError(403, 'Access denied');
    }

    if (dialog.assignedToId && dialog.assignedToId !== req.user!.id) {
      throw new AppError(400, 'Dialog already assigned to another manager');
    }

    const updatedDialog = await prisma.dialog.update({
      where: { id },
      data: {
        assignedToId: req.user!.id,
        assignedAt: new Date()
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            username: true
          }
        }
      }
    });
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–µ–π—Å—Ç–≤–∏–µ "–í–∑—è–ª —Å–µ–±–µ"
    await prisma.dialogAction.create({
      data: {
        dialogId: dialog.id,
        userId: req.user!.id,
        action: 'ASSIGNED'
      }
    });

    res.json(updatedDialog);
  } catch (error) {
    next(error);
  }
});

// Release dialog (–æ—Å–≤–æ–±–æ–¥–∏—Ç—å –¥–∏–∞–ª–æ–≥)
router.post('/:id/release', authenticate, async (req, res, next) => {
  try {
    const { id } = req.params;

    const dialog = await prisma.dialog.findUnique({
      where: { id },
      include: { bot: true }
    });

    if (!dialog) {
      throw new AppError(404, 'Dialog not found');
    }

    // –¢–æ–ª—å–∫–æ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –∏–ª–∏ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–≥—É—Ç –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –¥–∏–∞–ª–æ–≥
    if (dialog.assignedToId !== req.user!.id && dialog.bot.ownerId !== req.user!.id) {
      throw new AppError(403, 'Only assigned manager or owner can release dialog');
    }

    const updatedDialog = await prisma.dialog.update({
      where: { id },
      data: {
        assignedToId: null,
        assignedAt: null
      }
    });
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–µ–π—Å—Ç–≤–∏–µ "–û—Å–≤–æ–±–æ–¥–∏–ª"
    await prisma.dialogAction.create({
      data: {
        dialogId: dialog.id,
        userId: req.user!.id,
        action: 'RELEASED'
      }
    });

    res.json(updatedDialog);
  } catch (error) {
    next(error);
  }
});

// Transfer dialog (–ø–µ—Ä–µ–¥–∞—Ç—å –¥–∏–∞–ª–æ–≥ –¥—Ä—É–≥–æ–º—É –º–µ–Ω–µ–¥–∂–µ—Ä—É)
router.post('/:id/transfer', authenticate, async (req, res, next) => {
  try {
    const { id } = req.params;
    const { managerId } = req.body;

    if (!managerId) {
      throw new AppError(400, 'Manager ID is required');
    }

    const dialog = await prisma.dialog.findUnique({
      where: { id },
      include: { bot: true }
    });

    if (!dialog) {
      throw new AppError(404, 'Dialog not found');
    }

    // –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –¥–∏–∞–ª–æ–≥–∏
    if (dialog.bot.ownerId !== req.user!.id) {
      throw new AppError(403, 'Only bot owner can transfer dialogs');
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–µ–Ω–µ–¥–∂–µ—Ä —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø –∫ —ç—Ç–æ–º—É –±–æ—Ç—É
    const managerAccess = await prisma.botManager.findFirst({
      where: {
        userId: managerId,
        botId: dialog.botId
      },
      include: {
        user: {
          select: { isActive: true }
        }
      }
    });

    if (!managerAccess || !managerAccess.user.isActive) {
      throw new AppError(404, 'Manager not found or not active for this bot');
    }

    const updatedDialog = await prisma.dialog.update({
      where: { id },
      data: {
        assignedToId: managerId,
        assignedAt: new Date()
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            username: true
          }
        }
      }
    });
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–µ–π—Å—Ç–≤–∏–µ "–ü–µ—Ä–µ–¥–∞–ª"
    await prisma.dialogAction.create({
      data: {
        dialogId: dialog.id,
        userId: req.user!.id,
        action: 'TRANSFERRED',
        targetUserId: managerId
      }
    });

    res.json(updatedDialog);
  } catch (error) {
    next(error);
  }
});

// Get customer avatar
router.get('/:id/avatar', async (req, res, next) => {
  try {
    const { id } = req.params;
    const { token } = req.query;
    
    logger.info(`Avatar request for dialog ${id}, token: ${token ? 'provided' : 'missing'}`);

    // Verify token from query parameter
    if (!token || typeof token !== 'string') {
      throw new AppError(401, 'Authentication required');
    }

    // Verify JWT token
    const jwt = require('jsonwebtoken');
    let userId: string;
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
      userId = decoded.userId;
    } catch (error) {
      throw new AppError(401, 'Invalid token');
    }

    const dialog = await prisma.dialog.findUnique({
      where: { id },
      select: { 
        customerPhotoUrl: true,
        botId: true,
        bot: {
          select: {
            ownerId: true
          }
        }
      }
    });

    if (!dialog) {
      throw new AppError(404, 'Dialog not found');
    }

    // Check if user has access to this bot's dialogs
    const hasAccess = await (async () => {
      if (dialog.bot.ownerId === userId) return true;
      
      const managerAccess = await prisma.botManager.findFirst({
        where: {
          userId: userId,
          botId: dialog.botId
        }
      });
      
      return !!managerAccess;
    })();

    logger.info(`Avatar access check - userId: ${userId}, ownerId: ${dialog.bot.ownerId}, botId: ${dialog.botId}, hasAccess: ${hasAccess}`);

    if (!hasAccess) {
      throw new AppError(403, 'Access denied');
    }

    if (!dialog.customerPhotoUrl) {
      throw new AppError(404, 'No avatar available');
    }

    // If it's a Telegram URL, fetch and return as base64
    if (dialog.customerPhotoUrl.startsWith('https://api.telegram.org/')) {
      try {
        const response = await axios.get(dialog.customerPhotoUrl, {
          responseType: 'arraybuffer'
        });
        
        const buffer = Buffer.from(response.data);
        const base64 = buffer.toString('base64');
        const mimeType = response.headers['content-type'] || 'image/jpeg';
        const dataUrl = `data:${mimeType};base64,${base64}`;
        
        res.json({ avatarUrl: dataUrl });
      } catch (fetchError) {
        logger.error('Failed to fetch avatar from Telegram', fetchError);
        throw new AppError(500, 'Failed to fetch avatar');
      }
    } else {
      // If it's already a data URL, return it
      res.json({ avatarUrl: dialog.customerPhotoUrl });
    }
  } catch (error) {
    next(error);
  }
});

export default router;